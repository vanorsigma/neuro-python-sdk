# Generated by Claude, modified for SDK
import pygame
import sys

import json

from neurosdk.core.manager import Manager
from neurosdk.core.config import SDKConfig
from neurosdk.core.action.neuro_action import NeuroAction
from neurosdk.core.messages.action import Action, ResultActionData
from dataclasses import dataclass
from dataclasses_json import DataClassJsonMixin
from typing import Any

@dataclass
class SlotActionData(DataClassJsonMixin):
    coord_x: int
    coord_y: int

class ChooseSlotAction(NeuroAction):
    dataType = SlotActionData

    def __init__(self, tictactoe):
        self.ttt = tictactoe

    def get_name(self) -> str:
        return 'Choose slot'

    def get_description(self) -> str:
        return 'Make a valid move. Valid moves are: ' + json.dumps(self.ttt.get_all_valid_moves())

    def can_be_used(self) -> bool:
        return True

    def validate_action(self, data: str) -> bool:
        if super().validate_action(data):
            as_json = json.loads(data)
            x = as_json['coord_x']
            y = as_json['coord_y']

            print(x, y)

            if (x, y) not in self.ttt.get_all_valid_moves():
                print('invalid move')
                return False
            return True
        return False

    def execute_action(self, id: str, data: SlotActionData | None) -> ResultActionData:
        if data is None:
            print('no data to execute on')
            return ResultActionData(id=id, success=False, message="Invalid data to execute on")

        x = data.coord_x
        y = data.coord_y
        self.ttt.make_move(x, y)
        return ResultActionData(id=id, success=True, message="Moved successfully")

# Initialize Pygame
pygame.init()

# Constants
WINDOW_SIZE = 600
BOARD_SIZE = 3
CELL_SIZE = WINDOW_SIZE // BOARD_SIZE

# Colors
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
GRAY = (128, 128, 128)
RED = (255, 0, 0)

# Create the game window
screen = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))
pygame.display.set_caption("Tic Tac Toe")


class TicTacToe:
    def __init__(self):
        self.board = [["" for _ in range(BOARD_SIZE)] for _ in range(BOARD_SIZE)]
        self.current_player = "X"
        self.game_over = False
        self.winner = None
        self.waiting_for_ai = False

    def make_move(self, row, col):
        if self.board[row][col] == "" and not self.game_over:
            self.board[row][col] = self.current_player
            if self.check_winner(row, col):
                self.game_over = True
                self.winner = self.current_player
            elif self.is_board_full():
                self.game_over = True
            else:
                self.current_player = "O" if self.current_player == "X" else "X"
            return True
        return False

    def get_all_valid_moves(self) -> list[tuple[int, int]]:
        valid_coords = []
        for x, row in enumerate(self.board):
            for y, ele in enumerate(row):
                if len(ele) == 0:
                    valid_coords.append((x, y))
        return valid_coords

    def check_winner(self, row, col):
        # Check row
        if all(self.board[row][i] == self.current_player for i in range(BOARD_SIZE)):
            return True
        # Check column
        if all(self.board[i][col] == self.current_player for i in range(BOARD_SIZE)):
            return True
        # Check diagonals
        if row == col and all(
            self.board[i][i] == self.current_player for i in range(BOARD_SIZE)
        ):
            return True
        if row + col == BOARD_SIZE - 1 and all(
            self.board[i][BOARD_SIZE - 1 - i] == self.current_player
            for i in range(BOARD_SIZE)
        ):
            return True
        return False

    def is_board_full(self):
        return all(
            self.board[i][j] != "" for i in range(BOARD_SIZE) for j in range(BOARD_SIZE)
        )


def draw_board():
    screen.fill(WHITE)
    # Draw grid lines
    for i in range(1, BOARD_SIZE):
        pygame.draw.line(
            screen, BLACK, (i * CELL_SIZE, 0), (i * CELL_SIZE, WINDOW_SIZE), 2
        )
        pygame.draw.line(
            screen, BLACK, (0, i * CELL_SIZE), (WINDOW_SIZE, i * CELL_SIZE), 2
        )


def draw_markers(game):
    for row in range(BOARD_SIZE):
        for col in range(BOARD_SIZE):
            if game.board[row][col] == "X":
                # Draw X
                start_pos1 = (col * CELL_SIZE + 20, row * CELL_SIZE + 20)
                end_pos1 = ((col + 1) * CELL_SIZE - 20, (row + 1) * CELL_SIZE - 20)
                start_pos2 = (col * CELL_SIZE + 20, (row + 1) * CELL_SIZE - 20)
                end_pos2 = ((col + 1) * CELL_SIZE - 20, row * CELL_SIZE + 20)
                pygame.draw.line(screen, BLACK, start_pos1, end_pos1, 3)
                pygame.draw.line(screen, BLACK, start_pos2, end_pos2, 3)
            elif game.board[row][col] == "O":
                # Draw O
                center = (
                    col * CELL_SIZE + CELL_SIZE // 2,
                    row * CELL_SIZE + CELL_SIZE // 2,
                )
                pygame.draw.circle(screen, BLACK, center, CELL_SIZE // 2 - 20, 3)


def main():
    game = TicTacToe()
    font = pygame.font.Font(None, 74)
    config = SDKConfig(game_name='game', ws_url='ws://127.0.0.1:8000')
    manager = Manager(config)

    while True:
        if game.current_player == 'O' and not game.waiting_for_ai:
            action_group = manager.instantiate_action_window()
            action_group.add_action(ChooseSlotAction(game))
            action_group.set_force('Choose a slot', None, True)

            manager.register_active_action_window()
            game.waiting_for_ai = True
            continue
        elif game.current_player == 'X':
            game.waiting_for_ai = False

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

            if event.type == pygame.MOUSEBUTTONDOWN and not game.game_over and not game.waiting_for_ai:
                mouseX, mouseY = pygame.mouse.get_pos()
                row = mouseY // CELL_SIZE
                col = mouseX // CELL_SIZE
                game.make_move(row, col)

            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_r:  # Reset game when 'R' is pressed
                    game = TicTacToe()

        draw_board()
        draw_markers(game)

        if game.game_over:
            if game.winner:
                text = f"Player {game.winner} wins!"
            else:
                text = "It's a tie!"
            text_surface = font.render(text, True, RED)
            text_rect = text_surface.get_rect(
                center=(WINDOW_SIZE // 2, WINDOW_SIZE // 2)
            )
            screen.blit(text_surface, text_rect)

        pygame.display.flip()


if __name__ == "__main__":
    main()
